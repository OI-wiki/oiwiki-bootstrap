{
    "componentChunkName": "component---node-modules-gatsby-theme-oi-wiki-src-templates-doc-js",
    "path": "/lang/value-category/",
    "result": {"data":{"mdx":{"id":"76c10614-4ca1-55bf-8c47-8c0ed6d201b3","wordCount":{"words":397},"fields":{"slug":"/lang/value-category/","isIndex":false},"excerpt":"注意：这部分的内容很可能对算法竞赛无用，但如果你希望更深入地理解 C++，写出更高效的代码，那么本文的内容也许会对你有所帮助。 每个 C++ 表达式都有两个属性：类型 (type) 和值类别 (value category…","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"注意"}]},{"type":"text","value":"：这部分的内容很可能对算法竞赛无用，但如果你希望更深入地理解 C++，写出更高效的代码，那么本文的内容也许会对你有所帮助。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"每个 C++ 表达式都有两个属性：类型 (type) 和值类别 (value category)。前者是大家都熟悉的，但作为算法竞赛选手，很可能完全不知道后者是什么。不管你在不在意，值类别是 C++ 中非常重要的一个概念。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"details","properties":{"className":["note"],"open":"true"},"children":[{"type":"element","tagName":"summary","properties":{},"children":[{"type":"text","value":"关于名词的翻译"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"type 和 category 都可以翻译为“类型”或“类别”，但为了区分两者，下文中统一将 type 翻译为“类型”，category 翻译为“类别”。"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"从 CPL 语言的定义说起"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"从-cpl-语言的定义说起"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E4%BB%8E-cpl-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9A%E4%B9%89%E8%AF%B4%E8%B5%B7","ariaLabel":"从 cpl 语言的定义说起 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"左值与右值的概念最早出现在 C 语言的祖先语言：CPL。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在 CPL 的定义中，lvalue 意为 left-hand side value，即能够出现在赋值运算符（等号）左侧的值，右值的定义亦然。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"C 和 C++11 以前"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"c-和-c11-以前"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#c-%E5%92%8C-c11-%E4%BB%A5%E5%89%8D","ariaLabel":"c 和 c11 以前 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"C 语言沿用了相似的分类方法，但左右值的判断标准已经与赋值运算符无关。在新的定义中，lvalue 意为 locate value，即能进行取地址运算 ("},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"&"}]},{"type":"text","value":") 的值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以这么理解：左值是有内存地址的对象，而右值只是一个中间计算结果（虽然编译器往往需要在内存中分配地址来储存这个值，但这个内存地址是无法被程序员感知的，所以可以认为它不存在）。中间计算结果就意味着这个值马上就没用了，以后不会再访问它。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"比如在 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int a = 0;"}]},{"type":"text","value":" 这段代码中，"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a"}]},{"type":"text","value":" 就是一个左值，而 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0"}]},{"type":"text","value":" 是一个右值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"details","properties":{"className":["warning"],"open":"true"},"children":[{"type":"element","tagName":"summary","properties":{},"children":[{"type":"text","value":"常见的关于左右值的误解"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"以下几种类型是经常被误认为右值的左值："}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"字符串字面量"}]},{"type":"text","value":"：由于 C++ 兼容 C 风格的字符串，需要能对一个字符串字面量取地址（即头指针）来传参。但是其他的字面量，包括自定义字面量，都是右值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"数组"}]},{"type":"text","value":"：数组名就是数组首个元素的指针这种说法似乎误导了很多人，但这个说法显然是错误的，对数组进行取地址是可以编译的。数组名可以隐式的退化成首个元素的指针，这才是右值。"}]},{"type":"text","value":"\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"C++11 开始"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"c11-开始"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#c11-%E5%BC%80%E5%A7%8B","ariaLabel":"c11 开始 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"从 C++11 开始，为了配合移动语义，值的类别就不是左值右值这么简单了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"考虑一个简单的场景："}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们知道第三行的赋值运算复杂度是正比于 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a"}]},{"type":"text","value":" 的长度的，复制的开销很大。但有些情况下，比如 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a"}]},{"type":"text","value":" 在以后的代码中不会再使用，那么我们完全可以把 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a"}]},{"type":"text","value":" 所持有的内存“转移”到 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"b"}]},{"type":"text","value":" 上，这就是移动语义干的事情。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们姑且不管移动是怎么实现的，先来考虑一下我们如何标记 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a"}]},{"type":"text","value":" 是可以移动的。显然不管能否移动，这个表达式的类型都是 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"vector"}]},{"type":"text","value":" 不变，所以只能对值类别下手。不可移动的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a"}]},{"type":"text","value":" 是左值，如果要在原有的体系下标记可以移动的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a"}]},{"type":"text","value":"，我们只能把它标记为右值。但标记为右值又是不合理的，因为这个 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a"}]},{"type":"text","value":" 实际上拥有自己的内存地址，与其他右值有有根本上的不同。所以 C++11 引入了 亡值 (xvalue) 这一值类别来标记这一种表达式。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"于是我们现在有了三种类别：左值 (lvalue)、纯右值 (prvalue)、亡值 (xvalue)（纯右值就是原先的右值）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后我们发现亡值同时具有一些左值和纯右值的性质，比如它可以像左值一样取地址，又像右值一样不会再被访问。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以又有了两种组合类别：泛左值 (glvalue)（左值和亡值）、右值 (rvalue)（纯右值和亡值）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有一个初步的感性理解后，来看一下标准委员会对它们的定义："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"A "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"glvalue"}]},{"type":"text","value":"(generalized lvalue) is an expression whose evaluation determines the identity of an object, bit-field, or function."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"A "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"prvalue"}]},{"type":"text","value":"(pure rvalue) is an expression whose evaluation initializes an object or a bit-field, or computes the value of an operand of an operator, as specified by the context in which it appears, or an expression that has type cv void."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"An "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"xvalue"}]},{"type":"text","value":"(eXpiring value) is a glvalue that denotes an object or bit-field whose resources can be reused（usually because it is near the end of its lifetime）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"An "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"lvalue"}]},{"type":"text","value":" is a glvalue that is not an xvalue."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"An "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"rvalue"}]},{"type":"text","value":" is a prvalue or an xvalue."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"上述定义中提到了一个叫位域 (bit-field) 的东西。如果你不知道位域是什么，忽略它即可，后文也不会提及。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"其中关键的两个概念："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"是否拥有身份 (identity)：可以确定表达式是否与另一表达式指代同一实体，例如比较它们所标识的对象或函数的（直接或间接获得的）地址"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"是否可以被移动 (resources can be reused)：对象的资源可以移动到别的对象中"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这 5 种类型无非就是根据上面两种属性的是与否区分的，所以用下面的这张表格可以帮助理解："}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tagName":"table","properties":{},"children":[{"type":"element","tagName":"thead","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"th","properties":{},"children":[]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"拥有身份（glvalue）"}]},{"type":"element","tagName":"th","properties":{},"children":[{"type":"text","value":"不拥有身份"}]}]}]},{"type":"element","tagName":"tbody","properties":{},"children":[{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"可移动（rvalue）"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"xvalue"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"prvalue"}]}]},{"type":"element","tagName":"tr","properties":{},"children":[{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"不可移动"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"lvalue"}]},{"type":"element","tagName":"td","properties":{},"children":[{"type":"text","value":"不存在"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注意不拥有身份就意味着这个对象以后无法被访问，这样的对象显然是可以被移动的，所以不存在不拥有身份不可移动的值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"C++17 带来的新变化"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"c17-带来的新变化"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#c17-%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%96%B0%E5%8F%98%E5%8C%96","ariaLabel":"c17 带来的新变化 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"从拷贝到移动提升了不少速度，那么我们是否能够优化的更彻底一点，把移动的开销都省去呢？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"考虑这样的代码："}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"make_vector"}]},{"type":"text","value":" 函数根据一输入生成一个 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"vector"}]},{"type":"text","value":"。这个 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"vector"}]},{"type":"text","value":" 一开始在 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"make_vector"}]},{"type":"text","value":" 的栈上被构造，随后又被移动到调用者的栈上，需要一次移动操作，这显然很浪费，能不能省略这次移动？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"答案是肯定的，这就是 RVO 优化，即省略拷贝。通常的方法是编译器让 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"make_vector"}]},{"type":"text","value":" 返回的对象直接在调用者的栈上构造，然后 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"make_vector"}]},{"type":"text","value":" 在上面进行修改。这相当与这样的代码："}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在 C++17 以前，尽管标准未做出规定，但主流编译器都实现了这种优化。在 C++17 以后，这种优化成为标准的硬性规定。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"回到和移动语义刚被提出时的问题，如何确定一个移动赋值是可以省略的？再引入一种新的值类别？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不，C++11 的值类别已经够复杂了。我们意识到在 C++11 的标准下，亡值和纯右值都是可以移动的，那么就可以在这两种类别上做文章。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"C++17 以后，纯右值不再能移动，但可以隐式地转变为亡值。对于纯右值用于初始化的情况下，可以省略拷贝，而其他不能省略的情况下，隐式转换为亡值进行移动。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以在 C++17 之后的值类别，被更为整齐的划分为泛左值与纯右值两大块，右值存在的意义被削弱。这样的改变某种程度上简化了整个值类别体系。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"参考文献与推荐阅读"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"参考文献与推荐阅读"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E4%B8%8E%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB","ariaLabel":"参考文献与推荐阅读 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.cppreference.com/w/cpp/language/value_category"},"children":[{"type":"text","value":"Value categories"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html"},"children":[{"type":"text","value":"Wording for guaranteed copy elision through simplified value categories"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://paul.pub/cpp-value-category/"},"children":[{"type":"text","value":"C++ 中的值类别"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"style","properties":{},"children":[{"type":"text","value":".anchorLink.before{position:absolute;top:0;left:0;transform:translateX(-100%);padding-right:4px}.anchorLink.after{display:inline-block;padding-left:4px}h1 .anchorLink svg,h2 .anchorLink svg,h3 .anchorLink svg,h4 .anchorLink svg,h5 .anchorLink svg,h6 .anchorLink svg{visibility:hidden}h1 .anchorLink:focus svg,h1:hover .anchorLink svg,h2 .anchorLink:focus svg,h2:hover .anchorLink svg,h3 .anchorLink:focus svg,h3:hover .anchorLink svg,h4 .anchorLink:focus svg,h4:hover .anchorLink svg,h5 .anchorLink:focus svg,h5:hover .anchorLink svg,h6 .anchorLink:focus svg,h6:hover .anchorLink svg{visibility:visible}a.anchor{display:inline-block;position:relative;top:-159px;visibility:hidden}@media only screen and (max-width:1279.95px){a.anchor{top:-101px}}"}]}],"data":{"quirksMode":false}},"headings":[{"value":"从 CPL 语言的定义说起<a className=\"anchor\" id=\"从-cpl-语言的定义说起\"></a>","depth":2,"id":null},{"value":"C 和 C++11 以前<a className=\"anchor\" id=\"c-和-c11-以前\"></a>","depth":2,"id":null},{"value":"C++11 开始<a className=\"anchor\" id=\"c11-开始\"></a>","depth":2,"id":null},{"value":"C++17 带来的新变化<a className=\"anchor\" id=\"c17-带来的新变化\"></a>","depth":2,"id":null},{"value":"参考文献与推荐阅读<a className=\"anchor\" id=\"参考文献与推荐阅读\"></a>","depth":2,"id":null}],"frontmatter":{"author":"Ir1dXD, mingy, ksyx, Jacder","tags":["lang"],"title":"值类别","noMeta":null,"noComment":null,"description":null},"parent":{"relativePath":"lang/value-category.md","modifiedTime":"2023/02/03","birthTime":"2023-02-03T16:29:10.790Z","changeTime":"2023-02-03T16:29:10.790Z"}}},"pageContext":{"id":"76c10614-4ca1-55bf-8c47-8c0ed6d201b3","lastModified":"2022-02-12T20:36:07-06:00","next":{"node":{"fields":{"slug":"/math/fourier-motzkin-elimination/"},"id":"f53cd75c-309c-5e20-ae40-62fac04ab6a8","frontmatter":{"tags":["math"],"title":"傅里叶-莫茨金消元法"},"fileAbsolutePath":"/home/runner/work/oiwiki-bootstrap/oiwiki-bootstrap/cauldron/docs/math/fourier-motzkin-elimination.md"}}}},
    "staticQueryHashes": ["2462162885","2862490856","3656965534"]}