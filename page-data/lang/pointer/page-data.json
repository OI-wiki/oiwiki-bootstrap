{
    "componentChunkName": "component---node-modules-gatsby-theme-oi-wiki-src-templates-doc-js",
    "path": "/lang/pointer/",
    "result": {"data":{"mdx":{"id":"e0a1e622-e219-5853-96b4-8eea3cf47943","wordCount":{"words":660},"fields":{"slug":"/lang/pointer/","isIndex":false},"excerpt":"…","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"变量的地址、指针"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"变量的地址指针"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E6%8C%87%E9%92%88","ariaLabel":"变量的地址指针 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在程序中，我们的数据都有其存储的地址。在程序每次的实际运行过程中，变量在物理内存中的存储位置不尽相同。不过，我们仍能够在编程时，通过一定的语句，来取得数据在内存中的地址。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"地址也是数据。存放地址所用的变量类型有一个特殊的名字，叫做“指针变量”，有时也简称做“指针”。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"details","properties":{"className":["note"],"open":"true"},"children":[{"type":"element","tagName":"summary","properties":{},"children":[{"type":"text","value":"指针变量的大小"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"指针变量的大小在不同环境下有差异。在 32 位机上，地址用 32 位二进制整数表示，因此一个指针的大小为 4 字节。而 64 位机上，地址用 64 位二进制整数表示，因此一个指针的大小就变成了 8 字节。"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"地址只是一个刻度一般的数据，为了针对不同类型的数据，“指针变量”也有不同的类型，比如，可以有 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int"}]},{"type":"text","value":" 类型的指针变量，其中存储的地址（即指针变量存储的数值）对应一块大小为 32 位的空间的起始地址；有 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"char"}]},{"type":"text","value":" 类型的指针变量，其中存储的地址对应一块 8 位的空间的起始地址。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"事实上，用户也可以声明指向指针变量的指针变量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假如用户自定义了一个结构体："}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"则 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ThreeInt"}]},{"type":"text","value":" 类型的指针变量，对应着一块 3 × 32 = 96 bit 的空间。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"指针的声明与使用"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"指针的声明与使用"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E6%8C%87%E9%92%88%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8","ariaLabel":"指针的声明与使用 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"C/C++ 中，指针变量的类型为类型名后加上一个星号 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"*"}]},{"type":"text","value":"。比如，"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int"}]},{"type":"text","value":" 类型的指针变量的类型名即为 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int*"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们可以使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"&"}]},{"type":"text","value":" 符号取得一个变量的地址。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"要想访问指针变量地址所对应的空间（又称指针所 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"指向"}]},{"type":"text","value":" 的空间），需要对指针变量进行 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"解引用"}]},{"type":"text","value":"（dereference），使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"*"}]},{"type":"text","value":" 符号。"}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"对结构体变量也是类似。如果要访问指针指向的结构中的成员，需要先对指针进行解引用，再使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"."}]},{"type":"text","value":" 成员关系运算符。不过，更推荐使用“箭头”运算符 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"->"}]},{"type":"text","value":" 这一更简便的写法。"}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"指针的偏移"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"指针的偏移"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E6%8C%87%E9%92%88%E7%9A%84%E5%81%8F%E7%A7%BB","ariaLabel":"指针的偏移 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"指针变量也可以 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"和整数"}]},{"type":"text","value":" 进行加减操作。对于 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int"}]},{"type":"text","value":" 型指针，每加 1（递增 1），其指向的地址偏移 32 位（即 4 个字节）；若加 2，则指向的地址偏移 2 × 32 = 64 位。同理，对于 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"char"}]},{"type":"text","value":" 型指针，每次递增，其指向的地址偏移 8 位（即 1 个字节）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"使用指针偏移访问数组"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"使用指针偏移访问数组"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E5%81%8F%E7%A7%BB%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84","ariaLabel":"使用指针偏移访问数组 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们前面说过，数组是一块连续的存储空间。而在 C/C++ 中，直接使用数组名，得到的是数组的起始地址。"}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当通过指针访问数组中的元素时，往往需要用到“指针的偏移”，换句话说，即通过一个基地址（数组起始的地址）加上偏移量来访问。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们常用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"[]"}]},{"type":"text","value":" 运算符来访问数组中某一指定偏移量处的元素。比如 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a[3]"}]},{"type":"text","value":" 或者 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"p[4]"}]},{"type":"text","value":"。这种写法和对指针进行运算后再引用是等价的，即 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"p[4]"}]},{"type":"text","value":" 和 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"*(p + 4)"}]},{"type":"text","value":" 是等价的两种写法。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"空指针"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"空指针"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E7%A9%BA%E6%8C%87%E9%92%88","ariaLabel":"空指针 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在 C++11 之前，C++ 和 C 一样使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NULL"}]},{"type":"text","value":" 宏表示空指针常量，C++ 中 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NULL"}]},{"type":"text","value":" 的实现一般如下："}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"details","properties":{"className":["note"],"open":"true"},"children":[{"type":"element","tagName":"summary","properties":{},"children":[{"type":"text","value":"C 语言对 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NULL"}]},{"type":"text","value":" 的定义"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"C 语言在 C23 前有两个 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NULL"}]},{"type":"text","value":" 的定义，只有类型不同：一个是整型常量表达式，一个是转换为 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"void *"}]},{"type":"text","value":" 类型的常量表达式，但其值都为 0，编译器可任选一个实现。"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"空指针和整数 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"0"}]},{"type":"text","value":" 的混用在 C++ 中会导致许多问题，比如："}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在调用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"f(NULL)"}]},{"type":"text","value":" 时，实际调用的函数的类型是 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int(int)"}]},{"type":"text","value":" 而不是 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int(int *)"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"details","properties":{"className":["note"],"open":"true"},"children":[{"type":"element","tagName":"summary","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NULL"}]},{"type":"text","value":" 在 C 语言中造成的问题"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"比起在 C++ 中，因为有两个定义，在 C 语言中 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NULL"}]},{"type":"text","value":" 造成的问题更为严重：如果在一个传递可变参数的函数中，函数编写者想要接受一个指针，但是函数调用者传递了一个定义为整型的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NULL"}]},{"type":"text","value":"，则会造成未定义行为，因在函数内使用传入的可变参数时，要进行类型转换，而从整型到指针类型的转换是未定义行为。"},{"type":"element","tagName":"sup","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"#user-content-fn-note1","id":"user-content-fnref-note1","dataFootnoteRef":"","ariaDescribedBy":["footnote-label"]},"children":[{"type":"text","value":"1"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为了解决这些问题，C++11 引入了 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nullptr"}]},{"type":"text","value":" 关键字作为空指针常量。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"C++ 规定 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nullptr"}]},{"type":"text","value":" 可以隐式转换为任何指针类型，这种转换结果是该类型的空指针值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nullptr"}]},{"type":"text","value":" 的类型为 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"std::nullptr_t"}]},{"type":"text","value":", 称作空指针类型，可能的实现如下："}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"另外，C++11 起 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NULL"}]},{"type":"text","value":" 宏的实现也被修改为了："}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"details","properties":{"className":["note"],"open":"true"},"children":[{"type":"element","tagName":"summary","properties":{},"children":[{"type":"text","value":"C 语言对空指针常量的改进"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"基于类似的原因，C23 也引入了 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nullptr"}]},{"type":"text","value":" 作为空指针常量，同时引入了 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nullptr_t"}]},{"type":"text","value":" 作为其类型"},{"type":"element","tagName":"sup","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"#user-content-fn-note1","id":"user-content-fnref-note1-2","dataFootnoteRef":"","ariaDescribedBy":["footnote-label"]},"children":[{"type":"text","value":"1"}]}]},{"type":"text","value":"。"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"指针的进阶使用"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"指针的进阶使用"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8","ariaLabel":"指针的进阶使用 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"使用指针，使得程序编写者可以操作程序运行时中各处的数据，而不必局限于作用域。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"指针类型参数的使用"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"指针类型参数的使用"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8","ariaLabel":"指针类型参数的使用 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在 C/C++ 中，调用函数（过程）时使用的参数，均以拷贝的形式传入子过程中（引用除外，会在后续介绍）。默认情况下，函数仅能通过返回值，将结果返回到调用处。但是，如果某个函数希望修改其外部的数据，或者某个结构体/类的数据量较为庞大、不宜进行拷贝，这时，则可以通过向其传入外部数据的地址，便得以在其中访问甚至修改外部数据。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"下面的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"my_swap"}]},{"type":"text","value":" 方法，通过接收两个 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int"}]},{"type":"text","value":" 型的指针，在函数中使用中间变量，完成对两个 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int"}]},{"type":"text","value":" 型变量值的交换。"}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"C++ 中引入了引用的概念，相对于指针来说，更易用，也更安全。详情可以参见 "},{"type":"element","tagName":"a","properties":{"href":"./reference.md"},"children":[{"type":"text","value":"C++：引用"}]},{"type":"text","value":" 以及 "},{"type":"element","tagName":"a","properties":{"href":"./cpp-other-langs.md#%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8"},"children":[{"type":"text","value":"C 与 C++ 的区别：指针与引用"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"动态实例化"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"动态实例化"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E5%8A%A8%E6%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96","ariaLabel":"动态实例化 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"除此之外，程序编写时往往会涉及到动态内存分配，即，程序会在运行时，向操作系统动态地申请或归还存放数据所需的内存。当程序通过调用操作系统接口申请内存时，操作系统将返回程序所申请空间的地址。要使用这块空间，我们需要将这块空间的地址存储在指针变量中。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在 C++ 中，我们使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"new"}]},{"type":"text","value":" 运算符来获取一块内存，使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"delete"}]},{"type":"text","value":" 运算符释放某指针所指向的空间。"}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"上面的语句使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"new"}]},{"type":"text","value":" 运算符向操作系统申请了一块 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int"}]},{"type":"text","value":" 大小的空间，将其中的值初始化为 1234，并声明了一个 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int"}]},{"type":"text","value":" 型的指针 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"p"}]},{"type":"text","value":" 指向这块空间。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"同理，也可以使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"new"}]},{"type":"text","value":" 开辟新的对象："}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如上，「"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"new"}]},{"type":"text","value":" 表达式」将尝试开辟一块对应大小的空间，并尝试在这块空间上构造这一对象，并返回这一空间的地址。"}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"details","properties":{"className":["note"],"open":"true"},"children":[{"type":"element","tagName":"summary","properties":{},"children":[{"type":"text","value":"列表初始化"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"{}"}]},{"type":"text","value":" 运算符可以用来初始化没有构造函数的结构。除此之外，使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"{}"}]},{"type":"text","value":" 运算符可以使得变量的初始化形式变得统一。详见「"},{"type":"element","tagName":"a","properties":{"href":"https://en.cppreference.com/w/cpp/language/list_initialization"},"children":[{"type":"text","value":"list initialization (since C++11)"}]},{"type":"text","value":"」。"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"需要注意，当使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"new"}]},{"type":"text","value":" 申请的内存不再使用时，需要使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"delete"}]},{"type":"text","value":" 释放这块空间。不能对一块内存释放两次或以上。而对空指针 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nullptr"}]},{"type":"text","value":" 使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"delete"}]},{"type":"text","value":" 操作是合法的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"动态创建数组"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"动态创建数组"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84","ariaLabel":"动态创建数组 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"也可以使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"new[]"}]},{"type":"text","value":" 运算符创建数组，这时 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"new[]"}]},{"type":"text","value":" 运算符会返回数组的首地址，也就是数组第一个元素的地址，我们可以用对应类型的指针存储这个地址。释放时，则需要使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"delete[]"}]},{"type":"text","value":" 运算符。"}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"数组中元素的存储是连续的，即 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"p + 1"}]},{"type":"text","value":" 指向的是 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"p"}]},{"type":"text","value":" 的后继元素。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"二维数组"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"二维数组"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84","ariaLabel":"二维数组 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在存放矩阵形式的数据时，可能会用到“二维数组”这样的数据类型。从语义上来讲，二维数组是一个数组的数组。而计算机内存可以视作一个很长的一维数组。要在计算机内存中存放一个二维数组，便有“连续”与否的说法。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所谓“连续”，即二维数组的任意一行（row）的末尾与下一行的起始，在物理地址上是毗邻的，换言之，整个二维数组可以视作一个一维数组；反之，则二者在物理上不一定相邻。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"对于“连续”的二维数组，可以仅使用一个循环，借由一个不断递增的指针即可遍历数组中的所有数据。而对于非连续的二维数组，由于每一行不连续，则需要先取得某一行首的地址，再访问这一行中的元素。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"details","properties":{"className":["note"],"open":"true"},"children":[{"type":"element","tagName":"summary","properties":{},"children":[{"type":"text","value":"二维数组的存储方式"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这种按照“行（row）”存储数据的方式，称为行优先存储；相对的，也可以按照列（column）存储数据。由于计算机内存访问的特性，一般来说，访问连续的数据会得到更高的效率。因此，需要按照数据可能的使用方式，选择“行优先”或“列优先”的存储方式。"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"动态创建二维数组"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"动态创建二维数组"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84","ariaLabel":"动态创建二维数组 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在 C/C++ 中，我们可以使用类似下面这样的语句声明一个 N 行（row）M 列（column）的二维数组，其空间在物理上是连续的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"details","properties":{"className":["note"],"open":"true"},"children":[{"type":"element","tagName":"summary","properties":{},"children":[{"type":"text","value":"描述数组的维度"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"更通用的方式是使用第 n 维（dimension）的说法。对于“行优先”的存储形式，数组的第一维长度为 N，第二维长度为 M。"}]}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这种声明方式要求 N 和 M 为在编译期即可确定的常量表达式。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在 C/C++ 中，数组的第一个元素下标为 0，因此 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a[r][c]"}]},{"type":"text","value":" 这样的式子代表二维数组 a 中第 r + 1 行的第 c + 1 个元素，我们也称这个元素的下标为 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"(r,c)"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不过，实际使用中，（二维）数组的大小可能不是固定的，需要动态内存分配。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"常见的方式是声明一个长度为 N × M 的 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"一维数组"}]},{"type":"text","value":"，并通过下标 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"r * M + c"}]},{"type":"text","value":" 访问二维数组中下标为 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"(r, c)"}]},{"type":"text","value":" 的元素。"}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这种方法可以保证二维数组是 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"连续的"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"details","properties":{"className":["note"],"open":"true"},"children":[{"type":"element","tagName":"summary","properties":{},"children":[{"type":"text","value":"数组在物理层面上的线性存储"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"实际上，数据在内存中都可以视作线性存放的，因此在一定的规则下，通过动态开辟一维数组的空间，即可在其上存储 n 维的数组。"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"此外，亦可以根据“数组的数组”这一概念来进行内存的获取与使用。对于一个存放的若干数组的数组，实际上为一个存放的若干数组的首地址的数组，也就是一个存放若干指针变量的数组。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们需要一个变量来存放这个“数组的数组”的首地址——也就是一个指针的地址。这个变量便是一个“指向指针的指针”，有时也称作“二重指针”，如："}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接着，我们需要为每一个数组申请空间："}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"至此，我们便完成了内存的获取。而对于这样获得的内存的释放，则需要进行一个逆向的操作：即先释放每一个数组，再释放存储这些数组首地址的数组，如："}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"需要注意，这样获得的二维数组，不能保证其空间是连续的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"还有一种方式，需要使用到“指向数组的指针”。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"details","properties":{"open":true},"children":[{"type":"element","tagName":"summary","properties":{},"children":[{"type":"text","value":"note"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"们之前说到，在 C/C++ 中，直接使用数组名，值等于数组首元素的地址。但是数组名表示的这一变量的类型实际上是整个数组，而非单个元素。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"codeblock","properties":{"className":["gatsby-highlight"],"dataLanguage":"null"},"children":[{"type":"element","tagName":"pre","properties":{"className":["shiki"],"style":"background-color: var(--shiki-color-background);"},"children":[{"type":"element","tagName":"code","properties":{"className":["language-null"]},"children":[{"type":"text","value":"```cpp\nint main() { int a[5] = {1, 2, 3, 4, 5}; }\n```\n\n从概念上说，代码中标识符 `a` 的类型是 `int[5]`；从实际上来说，`a + 1` 所指向的地址相较于 `a` 指向的地址的偏移量为 5 个 `int` 型变量的长度。"}]}]}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这种方式获得到的也是连续的内存，但是可以直接使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a[n]"}]},{"type":"text","value":" 的形式获得到数组的第 n + 1 行（row）的首地址，因此，使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a[r][c]"}]},{"type":"text","value":" 的形式即可访问到下标为 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"(r, c)"}]},{"type":"text","value":" 的元素。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由于指向数组的指针也是一种确定的数据类型，因此除数组的第一维外，其他维度的长度均须为一个能在编译器确定的常量。不然，编译器将无法翻译如 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a[n]"}]},{"type":"text","value":" 这样的表达式（"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"a"}]},{"type":"text","value":" 为指向数组的指针）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"指向函数的指针"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"指向函数的指针"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88","ariaLabel":"指向函数的指针 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"关于函数的介绍请参见 "},{"type":"element","tagName":"a","properties":{"href":"./func.md"},"children":[{"type":"text","value":"C++ 函数"}]},{"type":"text","value":" 章节。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"简单地说，要调用一个函数，需要知晓该函数的参数类型、个数以及返回值类型，这些也统一称作接口类型。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以通过函数指针调用函数。有时候，若干个函数的接口类型是相同的，使用函数指针可以根据程序的运行 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"动态地"}]},{"type":"text","value":" 选择需要调用的函数。换句话说，可以在不修改一个函数的情况下，仅通过修改向其传入的参数（函数指针），使得该函数的行为发生变化。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假设我们有若干针对 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int"}]},{"type":"text","value":" 类型的二元运算函数，则函数的参数为 2 个 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int"}]},{"type":"text","value":"，返回值亦为 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int"}]},{"type":"text","value":"。下边是一个使用了函数指针的例子："}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"details","properties":{"className":["note"],"open":"true"},"children":[{"type":"element","tagName":"summary","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"&"}]},{"type":"text","value":"、"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"*"}]},{"type":"text","value":" 和函数指针"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在 C 语言中，诸如 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"void (*p)() = foo;"}]},{"type":"text","value":"、"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"void (*p)() = &foo;"}]},{"type":"text","value":"、"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"void (*p)() = *foo;"}]},{"type":"text","value":"、"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"void (*p)() = ***foo"}]},{"type":"text","value":" 等写法的结果是一样的。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因为函数（如 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"foo"}]},{"type":"text","value":"）是能够被隐式转换为指向函数的指针的，因此 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"void (*p)() = foo;"}]},{"type":"text","value":" 的写法能够成立。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"&"}]},{"type":"text","value":" 运算符可以取得到对象的地址，这对函数也是成立的，因此 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"void (*p)() = &foo;"}]},{"type":"text","value":" 的写法仍然成立。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"对函数指针使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"*"}]},{"type":"text","value":" 运算符可以取得指针指向的函数，而对于 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"**foo"}]},{"type":"text","value":" 这样的写法来说，"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"*foo"}]},{"type":"text","value":" 得到的是 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"foo"}]},{"type":"text","value":" 这个函数，紧接着又被隐式转换为指向 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"foo"}]},{"type":"text","value":" 的指针。如此类推，"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"**foo"}]},{"type":"text","value":" 得到的最终还是指向 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"foo"}]},{"type":"text","value":" 的函数指针；用户尽可以使用任意多的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"*"}]},{"type":"text","value":"，结果也是一样的。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"同理，在调用时使用类似 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"(*p)()"}]},{"type":"text","value":" 和 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"p()"}]},{"type":"text","value":" 的语句是一样的，可以省去 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"*"}]},{"type":"text","value":" 运算符。"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"参考资料："},{"type":"element","tagName":"a","properties":{"href":"https://stackoverflow.com/questions/6893285/why-do-function-pointer-definitions-work-with-any-number-of-ampersands-or-as"},"children":[{"type":"text","value":"Why do function pointer definitions work with any number of ampersands '&' or asterisks '*'? - stackoverflow.com"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"typdef"}]},{"type":"text","value":" 关键字声明函数指针的类型。"}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这样我们就可以在之后使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"p_bi_int_op"}]},{"type":"text","value":" 这种类型，即指向“参数为 2 个 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int"}]},{"type":"text","value":"，返回值亦为 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"int"}]},{"type":"text","value":"”的函数的指针。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以通过使用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"std::function"}]},{"type":"text","value":" 来更方便的引用函数。（未完待续）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"使用函数指针，可以实现“回调函数”。（未完待续）"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"参考资料与注释"},{"type":"element","tagName":"a","properties":{"className":["anchor"],"id":"参考资料与注释"},"children":[]},{"type":"element","tagName":"a","properties":{"href":"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E4%B8%8E%E6%B3%A8%E9%87%8A","ariaLabel":"参考资料与注释 permalink","className":["anchorLink","after"]},"children":[{"type":"element","tagName":"svg","properties":{"ariaHidden":"true","focusable":"false","height":"16","version":"1.1","viewBox":"0 0 16 16","width":"16"},"children":[{"type":"element","tagName":"path","properties":{"fillRule":"evenodd","d":"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"style","properties":{},"children":[{"type":"text","value":".anchorLink.before{position:absolute;top:0;left:0;transform:translateX(-100%);padding-right:4px}.anchorLink.after{display:inline-block;padding-left:4px}h1 .anchorLink svg,h2 .anchorLink svg,h3 .anchorLink svg,h4 .anchorLink svg,h5 .anchorLink svg,h6 .anchorLink svg{visibility:hidden}h1 .anchorLink:focus svg,h1:hover .anchorLink svg,h2 .anchorLink:focus svg,h2:hover .anchorLink svg,h3 .anchorLink:focus svg,h3:hover .anchorLink svg,h4 .anchorLink:focus svg,h4:hover .anchorLink svg,h5 .anchorLink:focus svg,h5:hover .anchorLink svg,h6 .anchorLink:focus svg,h6:hover .anchorLink svg{visibility:visible}a.anchor{display:inline-block;position:relative;top:-159px;visibility:hidden}@media only screen and (max-width:1279.95px){a.anchor{top:-101px}}"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"section","properties":{"dataFootnotes":"","className":["footnotes"]},"children":[{"type":"element","tagName":"h2","properties":{"className":["sr-only"],"id":"footnote-label"},"children":[{"type":"text","value":"Footnotes"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"user-content-fn-note1"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"参见 "},{"type":"element","tagName":"a","properties":{"href":"https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3042.htm"},"children":[{"type":"text","value":"Introduce the nullptr constant"}]},{"type":"text","value":" "},{"type":"element","tagName":"a","properties":{"href":"#user-content-fnref-note1","dataFootnoteBackref":"","className":["data-footnote-backref"],"ariaLabel":"Back to content"},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":" "},{"type":"element","tagName":"a","properties":{"href":"#user-content-fnref-note1-2","dataFootnoteBackref":"","className":["data-footnote-backref"],"ariaLabel":"Back to content"},"children":[{"type":"text","value":"↩"},{"type":"element","tagName":"sup","properties":{},"children":[{"type":"text","value":"2"}]}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"headings":[{"value":"变量的地址、指针<a className=\"anchor\" id=\"变量的地址指针\"></a>","depth":2,"id":null},{"value":"指针的声明与使用<a className=\"anchor\" id=\"指针的声明与使用\"></a>","depth":2,"id":null},{"value":"指针的偏移<a className=\"anchor\" id=\"指针的偏移\"></a>","depth":2,"id":null},{"value":"使用指针偏移访问数组<a className=\"anchor\" id=\"使用指针偏移访问数组\"></a>","depth":3,"id":null},{"value":"空指针<a className=\"anchor\" id=\"空指针\"></a>","depth":2,"id":null},{"value":"指针的进阶使用<a className=\"anchor\" id=\"指针的进阶使用\"></a>","depth":2,"id":null},{"value":"指针类型参数的使用<a className=\"anchor\" id=\"指针类型参数的使用\"></a>","depth":3,"id":null},{"value":"动态实例化<a className=\"anchor\" id=\"动态实例化\"></a>","depth":3,"id":null},{"value":"动态创建数组<a className=\"anchor\" id=\"动态创建数组\"></a>","depth":3,"id":null},{"value":"二维数组<a className=\"anchor\" id=\"二维数组\"></a>","depth":3,"id":null},{"value":"动态创建二维数组<a className=\"anchor\" id=\"动态创建二维数组\"></a>","depth":3,"id":null},{"value":"指向函数的指针<a className=\"anchor\" id=\"指向函数的指针\"></a>","depth":2,"id":null},{"value":"参考资料与注释<a className=\"anchor\" id=\"参考资料与注释\"></a>","depth":2,"id":null}],"frontmatter":{"author":"Tifa, queenwen, Lemon, henry_23, Camber, Ir1d","tags":["lang"],"title":"指针","noMeta":null,"noComment":null,"description":null},"parent":{"relativePath":"lang/pointer.md","modifiedTime":"2023/02/03","birthTime":"2023-02-03T16:29:10.794Z","changeTime":"2023-02-03T16:29:10.794Z"}}},"pageContext":{"id":"e0a1e622-e219-5853-96b4-8eea3cf47943","lastModified":"2022-10-12T00:32:05+00:00","next":{"node":{"fields":{"slug":"/math/combinatorics/combination/"},"id":"a6aebfe6-afa8-5957-8a26-b07a027c5b0d","frontmatter":{"tags":["math","combinatorics"],"title":"排列组合"},"fileAbsolutePath":"/home/runner/work/oiwiki-bootstrap/oiwiki-bootstrap/cauldron/docs/math/combinatorics/combination.md"}}}},
    "staticQueryHashes": ["2462162885","2862490856","3656965534"]}